
@inproceedings{chitra_analyzing_2020,
	address = {New York, NY, USA},
	series = {{WSDM} '20},
	title = {Analyzing the {Impact} of {Filter} {Bubbles} on {Social} {Network} {Polarization}},
	isbn = {9781450368223},
	url = {https://doi.org/10.1145/3336191.3371825},
	doi = {10.1145/3336191.3371825},
	abstract = {While social networks have increased the diversity of ideas and information available to users, they are also blamed for increasing the polarization of user opinions. Eli Pariser's "filter bubble" hypothesis [55] explains this counterintuitive phenomenon by linking user polarization to algorithmic filtering: to increase user engagement, social media companies connect users with ideas they are already likely to agree with, thus creating echo chambers of users with very similar beliefs. In this paper, we introduce a mathematical framework to assess the impact of this popular, yet unverified, hypothesis. We augment the classical Friedkin-Johnsen opinion dynamics model to include algorithmic filtering by introducing a network administrator --- an external actor that models social media companies by dynamically adjusting the strength of edges in a social network graph. When the network administrator is incentivized to reduce disagreement among interacting users, we experimentally demonstrate on networks from Reddit and Twitter that even small changes by the administrator to social network graphs can increase user polarization. We support our experiments with theoretical results by showing that social networks generated from the stochastic block model are provably sensitive to algorithmic filtering. Finally, we propose a simple modification to the incentives of the network administrator that limits the filter bubble effect without significantly affecting user engagement.},
	urldate = {2020-11-03},
	booktitle = {Proceedings of the 13th {International} {Conference} on {Web} {Search} and {Data} {Mining}},
	publisher = {Association for Computing Machinery},
	author = {Chitra, Uthsav and Musco, Christopher},
	month = jan,
	year = {2020},
	keywords = {algorithmic content filtering, filter bubbles, polarization, social networks, stochastic block model},
	pages = {115--123},
}

@phdthesis{may_cheminformatics_2015,
	type = {{PhD} {Thesis}},
	title = {Cheminformatics for genome-scale metabolic reconstructions},
	url = {https://doi.org/10.17863/CAM.15987},
	school = {Cambridge University},
	author = {May, John W.},
	year = {2015},
}

@article{edmonds_optimum_1967,
	title = {Optimum branchings},
	volume = {71},
	number = {4},
	journal = {Journal of Research of the national Bureau of Standards B},
	author = {Edmonds, Jack},
	year = {1967},
	pages = {233--240},
}

@article{edmonds_paths_1965,
	title = {Paths, {Trees}, and {Flowers}},
	volume = {17},
	issn = {0008-414X, 1496-4279},
	url = {https://www.cambridge.org/core/journals/canadian-journal-of-mathematics/article/paths-trees-and-flowers/08B492B72322C4130AE800C0610E0E21},
	doi = {10.4153/CJM-1965-045-4},
	abstract = {A graph G for purposes here is a finite set of elements called vertices and a finite set of elements called edges such that each edge meets exactly two vertices, called the end-points of the edge. An edge is said to join its end-points. A matching in G is a subset of its edges such that no two meet the same vertex. We describe an efficient algorithm for finding in a given graph a matching of maximum cardinality. This problem was posed and partly solved by C. Berge; see Sections 3.7 and 3.8.},
	language = {en},
	urldate = {2020-09-29},
	journal = {Canadian Journal of Mathematics},
	author = {Edmonds, Jack},
	year = {1965},
	pages = {449--467},
}

@inproceedings{chakrabarty_testing_2012,
	title = {Testing {Coverage} {Functions}},
	volume = {7391},
	isbn = {978-3-642-31593-0},
	url = {https://www.microsoft.com/en-us/research/publication/testing-coverage-functions/},
	abstract = {A coverage function f over a ground set [m] is associated with a universe U of weighted elements and m sets A 1,…,A m ⊆ U, and for any T ⊆ [m], f(T) is defined as the total weight of the elements in the union ∪ j ∈ T A j . Coverage functions are an important special case of submodular functions, and arise in many applications, for instance as a class of utility functions of agents in combinatorial auctions. Set functions such as coverage functions often lack succinct representations, and in algorithmic applications, an access to a value oracle is assumed. In this paper, we ask whether one can test if a given oracle is that of a coverage function or not. We demonstrate an algorithm which makes O(m{\textbar}U{\textbar}) queries to an oracle of a coverage function and completely reconstructs it. This gives a polytime tester for succinct coverage functions for which {\textbar}U{\textbar} is polynomially bounded in m. In contrast, we demonstrate a set function which is “far” from coverage, but requires 2Θ (m) queries to distinguish it from the class of coverage functions.},
	booktitle = {39th {International} {Colloquium}, {ICALP} 2012, {Warwick}, {UK}},
	publisher = {Springer Berlin Heidelberg},
	author = {Chakrabarty, Deeparnab and Huang, Zhiyi},
	month = jul,
	year = {2012},
	note = {Edition: 39th International Colloquium, ICALP 2012, Warwick, UK},
	pages = {170--181},
}

@article{roth_pairwise_2005,
	title = {Pairwise {Kidney} {Exchange}},
	volume = {125},
	url = {https://www.hbs.edu/faculty/Pages/item.aspx?num=19520},
	language = {en-us},
	number = {2},
	urldate = {2020-09-18},
	journal = {Journal of Economic Theory},
	author = {Roth, A. E. and Sonmez, Tayfun and Unver, M. Utku},
	month = dec,
	year = {2005},
	pages = {151--188},
}

@article{fujii_optimal_1969,
	title = {Optimal {Sequencing} of {Two} {Equivalent} {Processors}},
	volume = {17},
	issn = {0036-1399},
	url = {https://www.jstor.org/stable/2099319},
	abstract = {This paper presents an efficient algorithm for a class of sequencing problems in which n tasks with an arbitrary precedence relation have to be processed by two processors of equal ability, and each task requires one unit of time.},
	number = {4},
	urldate = {2020-09-18},
	journal = {SIAM Journal on Applied Mathematics},
	author = {Fujii, M. and Kasami, T. and Ninomiya, K.},
	year = {1969},
	pages = {784--789},
}

@article{zhu_group_2019,
	title = {Group {Influence} {Maximization} {Problem} in {Social} {Networks}},
	volume = {6},
	issn = {2329-924X},
	doi = {10.1109/TCSS.2019.2938575},
	abstract = {Group plays an important role in social society. Much of the world's decision or work is done by groups and teams. A group's decision should be made based on most of the members in the group that reach agreement on a concerned topic. If we want to spread a topic and maximize the total number of activated groups in a social network, which seed users should we choose. In this article, we will study a new influence maximization (IM) problem which focuses on the number of groups activated by some concerned topic or information. A group is said to be activated if β percent of users in this group are activated. Group IM (GIM) aims to select k seed users such that the number of eventually activated groups is maximized. We first analyze the complexity and approximability of GIM, which is NP-hard, and the objective function presented in this article is proven to be neither submodular nor supermodular. We develop an upper bound problem and a lower bound problem whose objective functions are submodular. Then, an algorithm based on group coverage will be proposed, and the Sandwich framework is formulated with theoretical analysis to solve GIM. Our experiments verify the effectiveness of our method, as well as the advantage of our method against the other heuristic methods.},
	number = {6},
	journal = {IEEE Transactions on Computational Social Systems},
	author = {Zhu, Jianming and Ghosh, Smita and Wu, Weili},
	month = dec,
	year = {2019},
	keywords = {Companies, GIM, Group influence maximization (GIM), Integrated circuit modeling, Linear programming, Mathematical model, NP-hard, Social networking (online), Upper bound, computational complexity, group coverage, group influence maximization problem, independent cascade (IC), lower bound problem, nonsubmodular, optimisation, sandwich framework, social network, social network theory, social networks, social society, upper bound problem},
	pages = {1156--1164},
}

@article{mitzenmacher_model_2019,
	title = {A {Model} for {Learned} {Bloom} {Filters}, and {Optimizing} by {Sandwiching}},
	url = {http://arxiv.org/abs/1901.00902},
	abstract = {Recent work has suggested enhancing Bloom filters by using a pre-filter, based on applying machine learning to determine a function that models the data set the Bloom filter is meant to represent. Here we model such learned Bloom filters,, with the following outcomes: (1) we clarify what guarantees can and cannot be associated with such a structure; (2) we show how to estimate what size the learning function must obtain in order to obtain improved performance; (3) we provide a simple method, sandwiching, for optimizing learned Bloom filters; and (4) we propose a design and analysis approach for a learned Bloomier filter, based on our modeling approach.},
	urldate = {2020-09-12},
	journal = {arXiv:1901.00902 [cs, stat]},
	author = {Mitzenmacher, Michael},
	month = jan,
	year = {2019},
	note = {arXiv: 1901.00902},
	keywords = {Computer Science - Databases, Computer Science - Machine Learning, Statistics - Machine Learning},
}

@misc{huang_induced_2019,
	title = {Induced subgraphs of hypercubes and a proof of the {Sensitivity} {Conjecture} {\textbar} {Annals} of {Mathematics}},
	url = {https://annals.math.princeton.edu/2019/190-3/p06},
	language = {en-US},
	urldate = {2020-09-01},
	author = {Huang, Hao},
	year = {2019},
}

@article{gotsman_equivalence_1992,
	title = {The equivalence of two problems on the cube},
	volume = {61},
	issn = {0097-3165},
	url = {https://www-sciencedirect-com.proxy.library.nyu.edu/science/article/pii/0097316592900608},
	doi = {10.1016/0097-3165(92)90060-8},
	abstract = {Denote by Qn the graph of the hypercube Cn = \{ +1, −1\}n. The following two seemingly unrelated questions are equivalent: 1. Let G be an induced subgra…},
	language = {en},
	number = {1},
	urldate = {2020-09-01},
	journal = {Journal of Combinatorial Theory, Series A},
	author = {Gotsman, C. and Linial, N.},
	month = sep,
	year = {1992},
	pages = {142--146},
}

@article{jeffery_quantum_2017,
	title = {Quantum algorithms for graph connectivity and formula evaluation},
	volume = {1},
	url = {https://quantum-journal.org/papers/q-2017-08-17-26/},
	doi = {10.22331/q-2017-08-17-26},
	abstract = {Stacey Jeffery and Shelby Kimmel,
Quantum 1, 26 (2017).
We give a new upper bound on the quantum query complexity of deciding \$st\$-connectivity on certain classes of planar graphs, and show the bound is sometimes exponentially better than previous…},
	language = {en-GB},
	urldate = {2020-09-05},
	journal = {Quantum},
	author = {Jeffery, Stacey and Kimmel, Shelby},
	month = aug,
	year = {2017},
	pages = {26},
}

@incollection{boyer_tight_2005,
	title = {Tight {Bounds} on {Quantum} {Searching}},
	copyright = {Copyright © 1999 Wiley‐VCH Verlag GmbH},
	isbn = {9783527603091},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/3527603093.ch10},
	abstract = {This chapter contains sections titled: Abstract 1 Introduction 2 Overview of Grover's Algorithm 3 Finding a Unique Solution 4 The Case of Multiple Solutions 5 The Case t = N/4 6 Unknown Number of Solutions 7 An Improved Lower Bound 8 Conclusions and Future Directions Acknowledgements References},
	language = {en},
	urldate = {2020-09-05},
	booktitle = {Quantum {Computing}},
	publisher = {John Wiley \& Sons, Ltd},
	author = {Boyer, Michel and Brassard, Gilles and Høyer, Peter and Tappa, Alain},
	year = {2005},
	doi = {10.1002/3527603093.ch10},
	keywords = {Grover's algorithm, quantum searching},
	pages = {187--199},
}

@incollection{brouwer_eigenvalues_2012,
	address = {New York, NY},
	series = {Universitext},
	title = {Eigenvalues and {Eigenvectors} of {Graphs}},
	isbn = {9781461419396},
	url = {https://doi.org/10.1007/978-1-4614-1939-6_3},
	abstract = {In this chapter, we apply the linear algebra from the previous chapter to graph spectra.},
	language = {en},
	urldate = {2020-09-01},
	booktitle = {Spectra of {Graphs}},
	publisher = {Springer},
	author = {Brouwer, Andries E. and Haemers, Willem H.},
	editor = {Brouwer, Andries E. and Haemers, Willem H.},
	year = {2012},
	doi = {10.1007/978-1-4614-1939-6_3},
	keywords = {Adjacency Matrix , Connected Graph , Large Eigenvalue , Regular Graph , Simplicial Complex },
	pages = {33--66},
}

@article{giovannetti_quantum_2008,
	title = {Quantum {Random} {Access} {Memory}},
	volume = {100},
	url = {https://link.aps.org/doi/10.1103/PhysRevLett.100.160501},
	doi = {10.1103/PhysRevLett.100.160501},
	abstract = {A random access memory (RAM) uses n bits to randomly address N=2n distinct memory cells. A quantum random access memory (QRAM) uses n qubits to address any quantum superposition of N memory cells. We present an architecture that exponentially reduces the requirements for a memory call: O(log N) switches need be thrown instead of the N used in conventional (classical or quantum) RAM designs. This yields a more robust QRAM algorithm, as it in general requires entanglement among exponentially less gates, and leads to an exponential decrease in the power needed for addressing. A quantum optical implementation is presented.},
	number = {16},
	urldate = {2020-07-24},
	journal = {Physical Review Letters},
	author = {Giovannetti, Vittorio and Lloyd, Seth and Maccone, Lorenzo},
	month = apr,
	year = {2008},
	note = {Publisher: American Physical Society},
	pages = {160501},
}

@book{gross_graph_2005,
	title = {Graph {Theory} and {Its} {Applications}, {Second} {Edition}},
	isbn = {978-1-58488-505-4},
	abstract = {Already an international bestseller, with the release of this greatly enhanced second edition, Graph Theory and Its Applications is now an even better choice as a textbook for a variety of courses -- a textbook that will continue to serve your students as a reference for years to come.The superior explanations, broad coverage, and abundance of illustrations and exercises that positioned this as the premier graph theory text remain, but are now augmented by a broad range of improvements. Nearly 200 pages have been added for this edition, including nine new sections and hundreds of new exercises, mostly non-routine. What else is new?New chapters on measurement and analytic graph theory Supplementary exercises in each chapter - ideal for reinforcing, reviewing, and testing.Solutions and hints, often illustrated with figures, to selected exercises - nearly 50 pages worthReorganization and extensive revisions in more than half of the existing chapters for smoother flow of the expositionForeshadowing - the first three chapters now preview a number of concepts, mostly via the exercises, to pique the interest of readerGross and Yellen take a comprehensive approach to graph theory that integrates careful exposition of classical developments with emerging methods, models, and practical needs. Their unparalleled treatment provides a text ideal for a two-semester course and a variety of one-semester classes, from an introductory one-semester course to courses slanted toward classical graph theory, operations research, data structures and algorithms, or algebra and topology.},
	language = {en},
	publisher = {CRC Press},
	author = {Gross, Jonathan L. and Yellen, Jay},
	month = sep,
	year = {2005},
	keywords = {Computers / Operating Systems / General, Computers / Programming / Algorithms, Mathematics / Combinatorics, Mathematics / Discrete Mathematics},
}

@article{gabow_path-based_2000,
	title = {Path-based depth-first search for strong and biconnected components},
	volume = {74},
	issn = {0020-0190},
	url = {http://www.sciencedirect.com/science/article/pii/S002001900000051X},
	doi = {10.1016/S0020-0190(00)00051-X},
	language = {en},
	number = {3},
	urldate = {2020-07-13},
	journal = {Information Processing Letters},
	author = {Gabow, Harold N.},
	month = may,
	year = {2000},
	keywords = {Algorithms, Biconnected component, Depth-first search, Graph, Stack, Strongly connected component},
	pages = {107--114},
}

@inproceedings{rivest_generalization_1975,
	address = {Albuquerque, New Mexico, USA},
	series = {{STOC} '75},
	title = {A generalization and proof of the {Aanderaa}-{Rosenberg} conjecture},
	isbn = {978-1-4503-7419-4},
	url = {https://doi.org/10.1145/800116.803747},
	doi = {10.1145/800116.803747},
	abstract = {We investigate the maximum number C(P) of arguments of P that must be tested in order to compute P, a Boolean function of d Boolean arguments. We present evidence for the general conjecture that C(P)=d whenever P(0d) @@@@ P(1d) and P is left invariant by a transitive permutation group acting on the arguments. A non-constructive argument (not based on the construction of an “oracle”) proves the generalized conjecture for d a prime power. We use this result to prove the Aanderaa-Rosenberg conjecture by showing that at least v2/9 entries of the adjacency matrix of a v-vertex undirected graph G must be examined in the worst case to determine if G has any given non-trivial monotone graph property.},
	urldate = {2020-07-12},
	booktitle = {Proceedings of the seventh annual {ACM} symposium on {Theory} of computing},
	publisher = {Association for Computing Machinery},
	author = {Rivest, Ronald L. and Vuillemin, Jean},
	month = may,
	year = {1975},
	pages = {6--11},
}

@article{greiner_finding_2006,
	title = {Finding optimal satisficing strategies for and-or trees},
	volume = {170},
	issn = {0004-3702},
	url = {http://www.sciencedirect.com/science/article/pii/S0004370205001438},
	doi = {10.1016/j.artint.2005.09.002},
	abstract = {Many tasks require evaluating a specified Boolean expression φ over a set of probabilistic tests whose costs and success probabilities are each known. A strategy specifies when to perform which test, towards determining the overall outcome of φ. We are interested in finding the strategy with the minimum expected cost. As this task is typically NP-hard—for example, when tests can occur many times within φ, or when there are probabilistic correlations between the test outcomes—we consider those cases in which the tests are probabilistically independent and each appears only once in φ. In such cases, φ can be written as an and-or tree, where each internal node corresponds to either the “and” or “or” of its children, and each leaf node is a probabilistic test. In this paper we investigate “probabilistic and-or tree resolution” (PAOTR), namely the problem of finding optimal strategies for and-or trees. We first consider a depth-first approach: evaluate each penultimate rooted subtree in isolation, replace each such subtree with a single “mega-test”, and recurse on the resulting reduced tree. We show that the strategies produced by this approach are optimal for and-or trees with depth at most two but can be arbitrarily sub-optimal for deeper trees. Each depth-first strategy can be described by giving the linear relative order in which tests are to be executed, with the understanding that any test whose outcome becomes irrelevant is skipped. The class of linear strategies is strictly larger than depth-first strategies. We show that even the best linear strategy can also be arbitrarily sub-optimal. We next prove that an optimal strategy honors a natural partial order among tests with a common parent node (“leaf-sibling tests”), and use this to produce a dynamic programming algorithm that finds the optimal strategy in time O(d2(r+1)d), where r is the maximum number of leaf-siblings and d is the number of leaf-parents; hence, for trees with a bounded number of internal nodes, this run-time is polynomial in the tree size. We also present another special class of and-or trees for which this task takes polynomial time. We close by presenting a number of other plausible approaches to PAOTR, together with counterexamples to show their limitations.},
	language = {en},
	number = {1},
	urldate = {2020-07-03},
	journal = {Artificial Intelligence},
	author = {Greiner, Russell and Hayward, Ryan and Jankowska, Magdalena and Molloy, Michael},
	month = jan,
	year = {2006},
	keywords = {And-or tree, Computational complexity, Diagnosis, Satisficing search},
	pages = {19--58},
}

@inproceedings{hoyer_negative_2007,
	address = {San Diego, California, USA},
	series = {{STOC} '07},
	title = {Negative weights make adversaries stronger},
	isbn = {978-1-59593-631-8},
	url = {https://doi.org/10.1145/1250790.1250867},
	doi = {10.1145/1250790.1250867},
	abstract = {The quantum adversary method is one of the most successful techniques for proving lower bounds on quantum query complexity. It gives optimal lower bounds for many problems, has application to classical complexity in formula size lower bounds, and is versatile with equivalent formulations interms of weight schemes, eigen values, and Kolmogorov complexity. All these formulations rely on the principlethat if an algorithm successfully computes a function then, in particular, itis able to distinguish between inputs which map to different values. We present a stronger version of the adversary method which goes beyond this principle to make explicit use of the stronger condition that the algorithm actually computes the function. This new method, which we call ADV+-, has all the advantages ofthe old: it is a lower bound on bounded-error quantum query complexity, its square is a lower bound on formula size, and it behaves well with respect tofunction composition. Moreover ADV+- is always at least as large as the adversary method ADV, and we show an example of a monotone function forwhich ADV+-(f)=Omega(ADV(f)1.098). We also give examples showing that ADV+- does not face limitations of ADV like the certificate complexity barrier and the property testing barrier.},
	urldate = {2020-06-26},
	booktitle = {Proceedings of the thirty-ninth annual {ACM} symposium on {Theory} of computing},
	publisher = {Association for Computing Machinery},
	author = {Hoyer, Peter and Lee, Troy and Spalek, Robert},
	month = jun,
	year = {2007},
	keywords = {adversary method, certificate complexity barrier, formula size, lower bounds, quantum computing, quantum query complexity},
	pages = {526--535},
}

@article{hoyer_lower_2005,
	title = {Lower {Bounds} on {Quantum} {Query} {Complexity}},
	url = {http://arxiv.org/abs/quant-ph/0509153},
	abstract = {Shor's and Grover's famous quantum algorithms for factoring and searching show that quantum computers can solve certain computational problems significantly faster than any classical computer. We discuss here what quantum computers\_cannot\_ do, and specifically how to prove limits on their computational power. We cover the main known techniques for proving lower bounds, and exemplify and compare the methods.},
	urldate = {2020-06-26},
	journal = {arXiv:quant-ph/0509153},
	author = {Hoyer, Peter and Spalek, Robert},
	month = sep,
	year = {2005},
	note = {arXiv: quant-ph/0509153},
	keywords = {Quantum Physics},
}

@article{arins_span-program-based_2015,
	title = {Span-program-based quantum algorithms for graph bipartiteness and connectivity},
	url = {http://arxiv.org/abs/1510.07825},
	abstract = {Span program is a linear-algebraic model of computation which can be used to design quantum algorithms. For any Boolean function there exists a span program that leads to a quantum algorithm with optimal quantum query complexity. In general, finding such span programs is not an easy task. In this work, given a query access to the adjacency matrix of a simple graph \$G\$ with \$n\$ vertices, we provide two new span-program-based quantum algorithms: an algorithm for testing if the graph is bipartite that uses \$O(n{\textbackslash}sqrt\{n\})\$ quantum queries; an algorithm for testing if the graph is connected that uses \$O(n{\textbackslash}sqrt\{n\})\$ quantum queries.},
	urldate = {2020-06-19},
	journal = {arXiv:1510.07825 [quant-ph]},
	author = {Āriņš, Agnis},
	month = oct,
	year = {2015},
	note = {arXiv: 1510.07825},
	keywords = {Computer Science - Computational Complexity, Computer Science - Data Structures and Algorithms, Quantum Physics},
}

@article{childs_quantum_2011,
	title = {Quantum query complexity of minor-closed graph properties},
	url = {http://arxiv.org/abs/1011.1443},
	doi = {10.4230/LIPIcs.STACS.2011.661},
	abstract = {We study the quantum query complexity of minor-closed graph properties, which include such problems as determining whether an \$n\$-vertex graph is planar, is a forest, or does not contain a path of a given length. We show that most minor-closed properties---those that cannot be characterized by a finite set of forbidden subgraphs---have quantum query complexity {\textbackslash}Theta(n{\textasciicircum}\{3/2\}). To establish this, we prove an adversary lower bound using a detailed analysis of the structure of minor-closed properties with respect to forbidden topological minors and forbidden subgraphs. On the other hand, we show that minor-closed properties (and more generally, sparse graph properties) that can be characterized by finitely many forbidden subgraphs can be solved strictly faster, in o(n{\textasciicircum}\{3/2\}) queries. Our algorithms are a novel application of the quantum walk search framework and give improved upper bounds for several subgraph-finding problems.},
	urldate = {2020-06-19},
	journal = {arXiv:1011.1443 [quant-ph]},
	author = {Childs, Andrew M. and Kothari, Robin},
	year = {2011},
	note = {arXiv: 1011.1443},
	keywords = {Computer Science - Computational Complexity, Computer Science - Data Structures and Algorithms, Quantum Physics},
	pages = {12 pages},
}

@article{zhang_power_2005,
	title = {On the power of {Ambainis} lower bounds},
	volume = {339},
	issn = {0304-3975},
	url = {http://www.sciencedirect.com/science/article/pii/S0304397505001234},
	doi = {10.1016/j.tcs.2005.01.019},
	abstract = {The polynomial method and the Ambainis lower bound (or Alb, for short) method are two main quantum lower bound techniques. While recently Ambainis showed that the polynomial method is not tight, the present paper aims at studying the power and limitation of Alb's. We first use known Alb's to derive Ω(n1.5) lower bounds for BIPARTITENESS, BIPARTITENESS MATCHING and GRAPH MATCHING, in which the lower bound for BIPARTITENESS improves the previous Ω(n) one. We then show that all the three known Ambainis lower bounds have a limitation Nmin\{C0(f),C1(f)\}, where C0(f) and C1(f) are the 0- and 1-certificate complexities, respectively. This implies that for many problems such as TRIANGLE, k-CLIQUE, BIPARTITENESS and BIPARTITE/GRAPH MATCHING which draw wide interest and whose quantum query complexities are still open, the best known lower bounds cannot be further improved by using Ambainis techniques. Another consequence is that all the Ambainis lower bounds are not tight. For total functions, this upper bound for Alb's can be further improved to min\{C0(f)C1(f),N·CI(f)\}, where CI(f) is the size of max intersection of a 0- and a 1-certificate set. Again this implies that Alb's cannot improve the best known lower bound for some specific problems such as AND-OR TREE, whose precise quantum query complexity is still open. Finally, we generalize the three known Alb's and give a new Alb style lower bound method, which may be easier to use for some problems.},
	language = {en},
	number = {2},
	urldate = {2020-06-19},
	journal = {Theoretical Computer Science},
	author = {Zhang, Shengyu},
	month = jun,
	year = {2005},
	keywords = {Lower bound technique, Quantum adversary method, Quantum computing, Quantum query complexity},
	pages = {241--256},
}

@article{durr_quantum_2006,
	title = {Quantum query complexity of some graph problems},
	volume = {35},
	issn = {0097-5397, 1095-7111},
	url = {http://arxiv.org/abs/quant-ph/0401091},
	doi = {10.1137/050644719},
	abstract = {Quantum algorithms for graph problems are considered, both in the adjacency matrix model and in an adjacency list-like array model. We give almost tight lower and upper bounds for the bounded error quantum query complexity of Connectivity, Strong Connectivity, Minimum Spanning Tree, and Single Source Shortest Paths. For example we show that the query complexity of Minimum Spanning Tree is in Theta(n{\textasciicircum}\{3/2\}) in the matrix model and in Theta(sqrt\{nm\}) in the array model, while the complexity of Connectivity is also in Theta(n{\textasciicircum}\{3/2\}) in the matrix model, but in Theta(n) in the array model. The upper bounds utilize search procedures for finding minima of functions under various conditions.},
	number = {6},
	urldate = {2020-06-17},
	journal = {SIAM Journal on Computing},
	author = {Durr, Christoph and Heiligman, Mark and Hoyer, Peter and Mhalla, Mehdi},
	month = jan,
	year = {2006},
	note = {arXiv: quant-ph/0401091},
	keywords = {Quantum Physics},
	pages = {1310--1328},
}

@article{furrow_panoply_2006,
	title = {A {Panoply} of {Quantum} {Algorithms}},
	url = {http://arxiv.org/abs/quant-ph/0606127},
	abstract = {We create a variety of new quantum algorithms that use Grover's algorithm and similar techniques to give polynomial speedups over their classical counterparts. We begin by introducing a set of tools that carefully minimize the impact of errors on running time; those tools provide us with speedups to already-published quantum algorithms, such as improving Durr, Heiligman, Hoyer and Mhalla's algorithm for single-source shortest paths [quant-ph/0401091] by a factor of lg N. The algorithms we construct from scratch have a range of speedups, from O(E)-{\textgreater}O(sqrt(VE lg V)) speedups in graph theory to an O(N{\textasciicircum}3)-{\textgreater}O(N{\textasciicircum}2) speedup in dynamic programming.},
	urldate = {2020-06-17},
	journal = {arXiv:quant-ph/0606127},
	author = {Furrow, Bartholomew},
	month = jun,
	year = {2006},
	note = {arXiv: quant-ph/0606127},
	keywords = {Quantum Physics},
}

@article{furrow_panoply_2008,
	title = {A panoply of quantum algorithms},
	doi = {10.14288/1.0085242},
	abstract = {This paper's aim is to explore improvements to, and applications of, a fundamental quantum algorithm invented by Grover[1]. Grover's algorithm is a basic tool that can be applied to a large number of problems in computer science, creating quantum algorithms that are polynomially faster than fastest known and fastest possible classical algorithms that solve the same problems. Our goal in this paper is to make these techniques readily accessible to those without a strong background in quantum physics: we achieve this by providing a set of tools, each of which makes use of Grover's algorithm or similar techniques, which can be used as subroutines in many quantum algorithms. 
 
The tools we provide are carefully constructed: they are easy to use, and in many cases they are asymptotically faster than the best tools previously available. The tools we build on include algorithms by Boyer, Brassard, Hoyer and Tapp[2], Buhrman, Cleve, de Witt and Zalka[3] and Durr and Hoyer[4]. 
 
After creating our tools, we create several new quantum algorithms, each of which is faster than the fastest known deterministic classical algorithm that accomplishes the same aim, and some of which are faster than the fastest possible deterministic classical algorithm. These algorithms solve problems from the fields of graph theory and computational geometry, and some employ dynamic programming techniques. We discuss a breadth-first search that is faster than Θ(edges) (the classical limit) in a dense graph, maximum-points-on-a-line in O(N3/2 lgN) (faster than the fastest classical algorithm known), as well as several other algorithms that are similarly illustrative of solutions in some class of problem. Through these new algorithms we illustrate the use of our tools, working to encourage their use and the study of quantum algorithms in general.},
	journal = {Quantum Inf. Comput.},
	author = {Furrow, Bartholomew},
	year = {2008},
}

@inproceedings{lyford_alex_applications_2020,
	address = {Bugibba, Malta},
	title = {Applications of {Graph} {Theory} and {Probability} in the {Board} {Game} {Ticket} to {Ride}},
	copyright = {All rights reserved},
	doi = {10.1145/3402942.3402963},
	booktitle = {Proceedings of the {International} {Conference} on the {Foundations} of {Digital} {Games}},
	author = {{Lyford, Alex} and {Witter, R. Teal}},
	year = {2020},
}

@inproceedings{delorenzo_applications_2019,
	title = {Applications of the {Quantum} {Algorithm} for st-{Connectivity}},
	volume = {135},
	copyright = {All rights reserved},
	url = {http://arxiv.org/abs/1904.05995},
	doi = {10.4230/LIPIcs.TQC.2019.6},
	abstract = {We present quantum algorithms for various problems related to graph connectivity. We give simple and query-optimal algorithms for cycle detection and odd-length cycle detection (bipartiteness) using a reduction to st-connectivity. Furthermore, we show that our algorithm for cycle detection has improved performance under the promise of large circuit rank or a small number of edges. We also provide algorithms for detecting even-length cycles and for estimating the circuit rank of a graph. All of our algorithms have logarithmic space complexity.},
	urldate = {2020-02-28},
	booktitle = {Proceedings of the {Conference} on the {Theory} of {Quantum} {Computation}, {Communication} and {Cryptography}},
	author = {DeLorenzo, Kai and Kimmel, Shelby and Witter, R. Teal},
	year = {2019},
	note = {arXiv: 1904.05995},
	keywords = {Computer Science - Computational Complexity, Computer Science - Data Structures and Algorithms, Quantum Physics},
	pages = {6:1--14},
}

@inproceedings{berzina_quantum_2004,
	title = {Quantum {Query} {Complexity} for {Some} {Graph} {Problems}},
	url = {https://link-springer-com.proxy.library.nyu.edu/chapter/10.1007/978-3-540-24618-3_11},
	doi = {10.1007/978-3-540-24618-3_11},
	abstract = {The paper [4] by H. Buhrman and R. de Wolf contains an impressive survey of solved and open problems in quantum query complexity, including many graph problems. We use recent results by A.Ambainis...},
	language = {en},
	urldate = {2020-06-01},
	booktitle = {{SOFSEM} 2004: {Theory} and {Practice} of {Computer} {Science}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Berzina, Aija and Dubrovsky, Andrej and Freivalds, Rusins and Lace, Lelde and Scegulnaja, Oksana},
	month = jan,
	year = {2004},
	pages = {140--150},
}

@article{cade_time_2016,
	title = {Time and {Space} {Efficient} {Quantum} {Algorithms} for {Detecting} {Cycles} and {Testing} {Bipartiteness}},
	url = {http://arxiv.org/abs/1610.00581},
	abstract = {We study space and time efficient quantum algorithms for two graph problems -- deciding whether an \$n\$-vertex graph is a forest, and whether it is bipartite. Via a reduction to the s-t connectivity problem, we describe quantum algorithms for deciding both properties in \${\textbackslash}tilde\{O\}(n{\textasciicircum}\{3/2\})\$ time and using \$O({\textbackslash}log n)\$ classical and quantum bits of storage in the adjacency matrix model. We then present quantum algorithms for deciding the two properties in the adjacency array model, which run in time \${\textbackslash}tilde\{O\}(n{\textbackslash}sqrt\{d\_m\})\$ and also require \$O({\textbackslash}log n)\$ space, where \$d\_m\$ is the maximum degree of any vertex in the input graph.},
	urldate = {2020-06-01},
	journal = {arXiv:1610.00581 [quant-ph]},
	author = {Cade, Chris and Montanaro, Ashley and Belovs, Aleksandrs},
	month = oct,
	year = {2016},
	note = {arXiv: 1610.00581},
	keywords = {Computer Science - Data Structures and Algorithms, Quantum Physics},
}

@article{farhi_limit_1998,
	title = {Limit on the {Speed} of {Quantum} {Computation} in {Determining} {Parity}},
	volume = {81},
	url = {https://link.aps.org/doi/10.1103/PhysRevLett.81.5442},
	doi = {10.1103/PhysRevLett.81.5442},
	abstract = {Consider a function f which is defined on the integers from 1 to N and takes the values −1 and +1. The parity of f is the product over all x from 1 to N of f(x). With no further information about f, to classically determine the parity of f requires N calls of the function f. We show that any quantum algorithm capable of determining the parity of f contains at least N/2 applications of the unitary operator which evaluates f. Thus, for this problem, quantum computers cannot outperform classical computers.},
	number = {24},
	urldate = {2020-05-08},
	journal = {Physical Review Letters},
	author = {Farhi, Edward and Goldstone, Jeffrey and Gutmann, Sam and Sipser, Michael},
	month = dec,
	year = {1998},
	note = {Publisher: American Physical Society},
	pages = {5442--5444},
}

@article{shor_polynomial-time_1999,
	title = {Polynomial-{Time} {Algorithms} for {Prime} {Factorization} and {Discrete} {Logarithms} on a {Quantum} {Computer}},
	volume = {41},
	issn = {0036-1445},
	url = {https://epubs.siam.org/doi/abs/10.1137/S0036144598347011},
	doi = {10.1137/S0036144598347011},
	abstract = {A digital computer is generally believed to be an efficient universal computing device; that is, it is believed to be able to simulate any physical computing device with an increase in computation time by at most a polynomial factor. This may not be true when quantum mechanics is taken into consideration. This paper considers factoring integers and finding discrete logarithms, two problems that are generally thought to be hard on classical computers and that have been used as the basis of several proposed cryptosystems. Efficient randomized algorithms are given for these two problems on a hypothetical quantum computer. These algorithms take a number of steps polynomial in the input size, for example, the number of digits of the integer to be factored.},
	number = {2},
	urldate = {2020-05-08},
	journal = {SIAM Review},
	author = {Shor, Peter W.},
	month = jan,
	year = {1999},
	note = {Publisher: Society for Industrial and Applied Mathematics},
	pages = {303--332},
}

@inproceedings{hales_improved_2000,
	address = {Redondo Beach, CA, USA},
	title = {An improved quantum {Fourier} transform algorithm and applications},
	isbn = {978-0-7695-0850-4},
	url = {http://ieeexplore.ieee.org/document/892139/},
	doi = {10.1109/SFCS.2000.892139},
	abstract = {We give an algorithm for approximating the quantum Fourier transform over an arbitrary Ô which requires only Ç´Ò ÐÓ Òµ steps where Ò ÐÓ Ô to achieve an approximation to within an arbitrary inverse polynomial in Ò. This improves the method of Kitaev [11] which requires time quadratic in Ò. This algorithm also leads to a general and efﬁcient Fourier sampling technique which improves upon the quantum Fourier sampling lemma of [8]. As an application of this technique we give a quantum algorithm which ﬁnds the period of an arbitrary periodic function, i.e. a function which may be many-to-one within each period. We show that this algorithm is efﬁcient (polylogarithmic in the period of the function) for a large class of periodic functions. Moreover, using standard quantum lower-bound techniques we show that this characterization is tight. That is, this is the maximal class of periodic functions with an efﬁcient quantum period-ﬁnding algorithm.},
	language = {en},
	urldate = {2020-05-08},
	booktitle = {Proceedings 41st {Annual} {Symposium} on {Foundations} of {Computer} {Science}},
	publisher = {IEEE Comput. Soc},
	author = {Hales, L. and Hallgren, S.},
	year = {2000},
	pages = {515--525},
}

@article{lin_upper_2016,
	title = {Upper bounds on quantum query complexity inspired by the {Elitzur}-{Vaidman}  bomb tester},
	volume = {12},
	doi = {10.4086/toc.2016.v012a018},
	number = {18},
	journal = {Theory of Computing},
	author = {Lin, Cedric and Lin, Han-Hsuan},
	year = {2016},
	pages = {1--35},
}

@article{gabow_weighted_2017,
	title = {The {Weighted} {Matching} {Approach} to {Maximum} {Cardinality} {Matching}},
	volume = {154},
	issn = {0169-2968},
	url = {https://content.iospress.com/articles/fundamenta-informaticae/fi1555},
	doi = {10.3233/FI-2017-1555},
	abstract = {Several papers have achieved time O n m for cardinality matching, starting from first principles. This results in a long derivation. We simplify the task by employing well-known concepts for maximum weight matching. We use Edmonds’ algorithm to deriv},
	language = {en},
	number = {1-4},
	urldate = {2020-05-06},
	journal = {Fundamenta Informaticae},
	author = {Gabow, Harold N.},
	month = jan,
	year = {2017},
	note = {Publisher: IOS Press},
	pages = {109--130},
}

@article{beigi_quantum_2020,
	title = {Quantum {Speedup} {Based} on {Classical} {Decision} {Trees}},
	volume = {4},
	url = {https://quantum-journal.org/papers/q-2020-03-02-241/},
	doi = {10.22331/q-2020-03-02-241},
	abstract = {Salman Beigi and Leila Taghavi,
Quantum 4, 241 (2020).
Lin and Lin [16] have recently shown how starting with a classical query algorithm (decision tree) for a function, we may find upper bounds on its quantum query complexity. More precisely, t…},
	language = {en-GB},
	urldate = {2020-05-06},
	journal = {Quantum},
	author = {Beigi, Salman and Taghavi, Leila},
	month = mar,
	year = {2020},
	note = {Publisher: Verein zur Förderung des Open Access Publizierens in den Quantenwissenschaften},
	pages = {241},
}

@article{trinajstic_solved_1986,
	title = {On some solved and unsolved problems of chemical graph theory},
	volume = {30},
	copyright = {Copyright © 1986 John Wiley \& Sons, Inc.},
	issn = {1097-461X},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/qua.560300762},
	doi = {10.1002/qua.560300762},
	abstract = {The development of several novel graph theoretical concepts and their applications in different branches of chemistry are reviewed. After a few introductory remarks we follow with an outline of selected important graph theoretical invariants, introducing some new results and indicating some open problems. We continue with discussing the problem of graph characterization and construction of graphs of chemical interest, with a particular emphasis on large systems. Finally we consider various problems and difficulties associated with special subgraphs, including subgraphs representing Kekulé valence structures. The paper ends with a brief review of structure-property and structure-activity correlations, the topic which is one of prime motivations for application of graph theory to chemistry.},
	language = {en},
	number = {S20},
	urldate = {2020-05-06},
	journal = {International Journal of Quantum Chemistry},
	author = {Trinajstić, Nenad and Klein, Douglas J. and Randić, Milan},
	year = {1986},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/qua.560300762},
	pages = {699--742},
}

@article{durr_quantum_2003,
	title = {Quantum query complexity of graph connectivity},
	url = {http://arxiv.org/abs/quant-ph/0303169},
	abstract = {Harry Buhrman et al gave an Omega(sqrt n) lower bound for monotone graph properties in the adjacency matrix query model. Their proof is based on the polynomial method. However for some properties stronger lower bounds exist. We give an Omega(n{\textasciicircum}\{3/2\}) bound for Graph Connectivity using Andris Ambainis' method, and an O(n{\textasciicircum}\{3/2\} log n) upper bound based on Grover's search algorithm. In addition we study the adjacency list query model, where we have almost matching lower and upper bounds for Strong Connectivity of directed graphs.},
	urldate = {2020-04-26},
	journal = {arXiv:quant-ph/0303169},
	author = {Durr, Christoph and Mhalla, Mehdi and Lei, Yaohui},
	month = apr,
	year = {2003},
	note = {arXiv: quant-ph/0303169},
	keywords = {Quantum Physics},
}

@article{ambainis_quantum_2002,
	title = {Quantum {Lower} {Bounds} by {Quantum} {Arguments}},
	volume = {64},
	issn = {0022-0000},
	url = {http://www.sciencedirect.com/science/article/pii/S002200000291826X},
	doi = {10.1006/jcss.2002.1826},
	abstract = {We propose a new method for proving lower bounds on quantum query algorithms. Instead of a classical adversary that runs the algorithm with one input and then modifies the input, we use a quantum adversary that runs the algorithm with a superposition of inputs. If the algorithm works correctly, its state becomes entangled with the superposition over inputs. We bound the number of queries needed to achieve a sufficient entanglement and this implies a lower bound on the number of queries for the computation. Using this method, we prove two new Ω(N) lower bounds on computing AND of ORs and inverting a permutation and also provide more uniform proofs for several known lower bounds which have been previously proven via a variety of different techniques.},
	language = {en},
	number = {4},
	urldate = {2020-04-26},
	journal = {Journal of Computer and System Sciences},
	author = {Ambainis, Andris},
	month = jun,
	year = {2002},
	keywords = {quantum computing, quantum lower bounds, quantum query algorithms.},
	pages = {750--767},
}

@inproceedings{grover_fast_1996,
	address = {Philadelphia, Pennsylvania, USA},
	series = {{STOC} '96},
	title = {A fast quantum mechanical algorithm for database search},
	isbn = {978-0-89791-785-8},
	url = {https://doi.org/10.1145/237814.237866},
	doi = {10.1145/237814.237866},
	urldate = {2020-04-25},
	booktitle = {Proceedings of the twenty-eighth annual {ACM} symposium on {Theory} of {Computing}},
	publisher = {Association for Computing Machinery},
	author = {Grover, Lov K.},
	month = jul,
	year = {1996},
	pages = {212--219},
}

@article{lee_quantum_2011,
	title = {Quantum query complexity of state conversion},
	url = {http://arxiv.org/abs/1011.3020},
	doi = {10.1109/FOCS.2011.75},
	abstract = {State conversion generalizes query complexity to the problem of converting between two input-dependent quantum states by making queries to the input. We characterize the complexity of this problem by introducing a natural information-theoretic norm that extends the Schur product operator norm. The complexity of converting between two systems of states is given by the distance between them, as measured by this norm. In the special case of function evaluation, the norm is closely related to the general adversary bound, a semi-definite program that lower-bounds the number of input queries needed by a quantum algorithm to evaluate a function. We thus obtain that the general adversary bound characterizes the quantum query complexity of any function whatsoever. This generalizes and simplifies the proof of the same result in the case of boolean input and output. Also in the case of function evaluation, we show that our norm satisfies a remarkable composition property, implying that the quantum query complexity of the composition of two functions is at most the product of the query complexities of the functions, up to a constant. Finally, our result implies that discrete and continuous-time query models are equivalent in the bounded-error setting, even for the general state-conversion problem.},
	urldate = {2020-04-09},
	journal = {2011 IEEE 52nd Annual Symposium on Foundations of Computer Science},
	author = {Lee, Troy and Mittal, Rajat and Reichardt, Ben W. and Spalek, Robert and Szegedy, Mario},
	month = oct,
	year = {2011},
	note = {arXiv: 1011.3020},
	keywords = {Quantum Physics},
	pages = {344--353},
}

@article{reichardt_reflections_2010,
	title = {Reflections for quantum query algorithms},
	url = {http://arxiv.org/abs/1005.1601},
	abstract = {We show that any boolean function can be evaluated optimally by a quantum query algorithm that alternates a certain fixed, input-independent reflection with a second reflection that coherently queries the input string. Originally introduced for solving the unstructured search problem, this two-reflections structure is therefore a universal feature of quantum algorithms. Our proof goes via the general adversary bound, a semi-definite program (SDP) that lower-bounds the quantum query complexity of a function. By a quantum algorithm for evaluating span programs, this lower bound is known to be tight up to a sub-logarithmic factor. The extra factor comes from converting a continuous-time query algorithm into a discrete-query algorithm. We give a direct and simplified quantum algorithm based on the dual SDP, with a bounded-error query complexity that matches the general adversary bound. Therefore, the general adversary lower bound is tight; it is in fact an SDP for quantum query complexity. This implies that the quantum query complexity of the composition f(g,...,g) of two boolean functions f and g matches the product of the query complexities of f and g, without a logarithmic factor for error reduction. It further shows that span programs are equivalent to quantum query algorithms.},
	urldate = {2020-04-04},
	journal = {arXiv:1005.1601 [quant-ph]},
	author = {Reichardt, Ben W.},
	month = may,
	year = {2010},
	note = {arXiv: 1005.1601},
	keywords = {Quantum Physics},
}

@article{ito_approximate_2015,
	title = {Approximate {Span} {Programs}},
	url = {http://arxiv.org/abs/1507.00432},
	abstract = {Span programs are a model of computation that have been used to design quantum algorithms, mainly in the query model. For any decision problem, there exists a span program that leads to an algorithm with optimal quantum query complexity, but finding such an algorithm is generally challenging. We consider new ways of designing quantum algorithms using span programs. We show how any span program that decides a problem \$f\$ can also be used to decide "property testing" versions of \$f\$, or more generally, approximate the span program witness size, a property of the input related to \$f\$. For example, using our techniques, the span program for OR, which can be used to design an optimal algorithm for the OR function, can also be used to design optimal algorithms for: threshold functions, in which we want to decide if the Hamming weight of a string is above a threshold or far below, given the promise that one of these is true; and approximate counting, in which we want to estimate the Hamming weight of the input. We achieve these results by relaxing the requirement that 1-inputs hit some target exactly in the span program, which could make design of span programs easier. We also give an exposition of span program structure, which increases the understanding of this important model. One implication is alternative algorithms for estimating the witness size when the phase gap of a certain unitary can be lower bounded. We show how to lower bound this phase gap in some cases. As applications, we give the first upper bounds in the adjacency query model on the quantum time complexity of estimating the effective resistance between \$s\$ and \$t\$, \$R\_\{s,t\}(G)\$, of \${\textbackslash}tilde O({\textbackslash}frac\{1\}\{{\textbackslash}epsilon{\textasciicircum}\{3/2\}\}n{\textbackslash}sqrt\{R\_\{s,t\}(G)\})\$, and, when \${\textbackslash}mu\$ is a lower bound on \${\textbackslash}lambda\_2(G)\$, by our phase gap lower bound, we can obtain \${\textbackslash}tilde O({\textbackslash}frac\{1\}\{{\textbackslash}epsilon\}n{\textbackslash}sqrt\{R\_\{s,t\}(G)/{\textbackslash}mu\})\$, both using \$O({\textbackslash}log n)\$ space.},
	urldate = {2020-04-04},
	journal = {arXiv:1507.00432 [quant-ph]},
	author = {Ito, Tsuyoshi and Jeffery, Stacey},
	month = jul,
	year = {2015},
	note = {arXiv: 1507.00432},
	keywords = {Computer Science - Computational Complexity, Quantum Physics},
}

@article{beigi_span_2019,
	title = {Span {Program} for {Non}-binary {Functions}},
	url = {http://arxiv.org/abs/1805.02714},
	abstract = {Span programs characterize the quantum query complexity of binary functions \$f:{\textbackslash}\{0,{\textbackslash}ldots,{\textbackslash}ell{\textbackslash}\}{\textasciicircum}n {\textbackslash}to {\textbackslash}\{0,1{\textbackslash}\}\$ up to a constant factor. In this paper we generalize the notion of span programs for functions with non-binary input/output alphabets \$f: [{\textbackslash}ell]{\textasciicircum}n {\textbackslash}to [m]\$. We show that non-binary span program characterizes the quantum query complexity of any such function up to a constant factor. We argue that this non-binary span program is indeed the generalization of its binary counterpart. We also generalize the notion of span programs for a special class of relations. Learning graphs provide another tool for designing quantum query algorithms for binary functions. In this paper, we also generalize this tool for non-binary functions, and as an application of our non-binary span program show that any non-binary learning graph gives an upper bound on the quantum query complexity.},
	urldate = {2020-03-31},
	journal = {arXiv:1805.02714 [quant-ph]},
	author = {Beigi, Salman and Taghavi, Leila},
	month = may,
	year = {2019},
	note = {arXiv: 1805.02714},
	keywords = {Computer Science - Computational Complexity, Quantum Physics},
}

@article{band_quantum_2017,
	title = {Quantum graphs which optimize the spectral gap},
	volume = {18},
	issn = {1424-0637, 1424-0661},
	url = {http://arxiv.org/abs/1608.00520},
	doi = {10.1007/s00023-017-0601-2},
	abstract = {A finite discrete graph is turned into a quantum (metric) graph once a finite length is assigned to each edge and the one-dimensional Laplacian is taken to be the operator. We study the dependence of the spectral gap (the first positive Laplacian eigenvalue) on the choice of edge lengths. In particular, starting from a certain discrete graph, we seek the quantum graph for which an optimal (either maximal or minimal) spectral gap is obtained. We fully solve the minimization problem for all graphs. We develop tools for investigating the maximization problem and solve it for some families of graphs.},
	number = {10},
	urldate = {2020-03-26},
	journal = {Annales Henri Poincaré},
	author = {Band, Ram and Lévy, Guillaume},
	month = oct,
	year = {2017},
	note = {arXiv: 1608.00520},
	keywords = {05C45, 34L15, 35Pxx, 35R02, Mathematical Physics, Mathematics - Spectral Theory},
	pages = {3269--3323},
}

@inproceedings{micali_ovv_1980,
	title = {An {O}(v{\textbar}v{\textbar} c {\textbar}{E}{\textbar}) algoithm for finding maximum matching in general graphs},
	doi = {10.1109/SFCS.1980.12},
	abstract = {In this paper we present an 0(√{\textbar}V{\textbar}·{\textbar}E{\textbar}) algorithm for finding a maximum matching in general graphs. This algorithm works in 'phases'. In each phase a maximal set of disjoint minimum length augmenting paths is found, and the existing matching is increased along these paths. Our contribution consists in devising a special way of handling blossoms, which enables an O({\textbar}E{\textbar}) implementation of a phase. In each phase, the algorithm grows Breadth First Search trees at all unmatched vertices. When it detects the presence of a blossom, it does not 'shrink' the blossom immediately. Instead, it delays the shrinking in such a way that the first augmenting path found is of minimum length. Furthermore, it achieves the effect of shrinking a blossom by a special labeling procedure which enables it to find an augmenting path through a blossom quickly.},
	booktitle = {21st {Annual} {Symposium} on {Foundations} of {Computer} {Science} (sfcs 1980)},
	author = {Micali, Silvio and Vazirani, Vijay V.},
	month = oct,
	year = {1980},
	note = {ISSN: 0272-5428},
	keywords = {Delay, History, Labeling, Scholarships},
	pages = {17--27},
}

@article{dorn_quantum_2009,
	title = {Quantum {Algorithms} for {Matching} {Problems}},
	volume = {45},
	doi = {10.1007/s00224-008-9118-x},
	abstract = {We present quantum algorithms for the following matching problems in unweighted and weighted graphs with n vertices and m edges: Finding a maximal matching in general graphs in time O(nmlog 2 n). Finding a maximum matching in general graphs in time O(nmlog 2 n). Finding a maximum weight matching in bipartite graphs in time O(nmNlog 2 n), where N is the largest edge weight. Our quantum algorithms are faster than the best known classical deterministic algorithms for the corresponding problems. In particular, the second result solves an open question stated in a paper by A. Ambainis and R. Špalek [Lect. Notes. Comput. Sci. 3884, 172–183 (2006; Zbl 1136.68395)].},
	journal = {Theory Comput. Syst.},
	author = {Dörn, Sebastian},
	month = jul,
	year = {2009},
	pages = {613--628},
}

@inproceedings{ambainis_quantum_2006,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Quantum {Algorithms} for {Matching} and {Network} {Flows}},
	isbn = {978-3-540-32288-7},
	doi = {10.1007/11672142_13},
	abstract = {We present quantum algorithms for some graph problems: finding a maximal bipartite matching in time 𝑂(𝑛𝑚‾‾√𝑙𝑜𝑔𝑛)O(nmlogn)O(n{\textbackslash}sqrt\{m\}logn), finding a maximal non-bipartite matching in time 𝑂(𝑛2(𝑚/𝑛‾‾‾‾√+𝑙𝑜𝑔𝑛)𝑙𝑜𝑔𝑛)O(n2(m/n+logn)logn)O(n{\textasciicircum}2({\textbackslash}sqrt\{m/n\}+log n)log n), and finding a maximal flow in an integer network in time 𝑂(𝑚𝑖𝑛(𝑛7/6𝑚‾‾√⋅𝑈1/3,𝑛𝑈‾‾‾√𝑚)𝑙𝑜𝑔𝑛)O(min(n7/6m⋅U1/3,nUm)logn)O(min(n{\textasciicircum}\{7/6\} {\textbackslash}sqrt\{m\} {\textbackslash}cdot U{\textasciicircum}\{1/3\},{\textbackslash}sqrt\{nU\}m)log n), where n is the number of vertices, m is the number of edges, and U ≤ n 1/4 is an upper bound on the capacity of an edge.},
	language = {en},
	booktitle = {{STACS} 2006},
	publisher = {Springer},
	author = {Ambainis, Andris and Špalek, Robert},
	editor = {Durand, Bruno and Thomas, Wolfgang},
	year = {2006},
	keywords = {Bipartite Match, Classical Algorithm, Graph Problem, Network Flow, Quantum Algorithm},
	pages = {172--183},
}

@article{reichardt_span_2009,
	title = {Span programs and quantum query complexity: {The} general adversary bound is nearly tight for every boolean function},
	shorttitle = {Span programs and quantum query complexity},
	url = {http://arxiv.org/abs/0904.2759},
	doi = {10.1109/FOCS.2009.55},
	abstract = {The general adversary bound is a semi-definite program (SDP) that lower-bounds the quantum query complexity of a function. We turn this lower bound into an upper bound, by giving a quantum walk algorithm based on the dual SDP that has query complexity at most the general adversary bound, up to a logarithmic factor. In more detail, the proof has two steps, each based on "span programs," a certain linear-algebraic model of computation. First, we give an SDP that outputs for any boolean function a span program computing it that has optimal "witness size." The optimal witness size is shown to coincide with the general adversary lower bound. Second, we give a quantum algorithm for evaluating span programs with only a logarithmic query overhead on the witness size. The first result is motivated by a quantum algorithm for evaluating composed span programs. The algorithm is known to be optimal for evaluating a large class of formulas. The allowed gates include all constant-size functions for which there is an optimal span program. So far, good span programs have been found in an ad hoc manner, and the SDP automates this procedure. Surprisingly, the SDP's value equals the general adversary bound. A corollary is an optimal quantum algorithm for evaluating "balanced" formulas over any finite boolean gate set. The second result extends span programs' applicability beyond the formula evaluation problem. A strong universality result for span programs follows. A good quantum query algorithm for a problem implies a good span program, and vice versa. Although nearly tight, this equivalence is nontrivial. Span programs are a promising model for developing more quantum algorithms.},
	urldate = {2020-03-01},
	journal = {2009 50th Annual IEEE Symposium on Foundations of Computer Science},
	author = {Reichardt, Ben W.},
	month = oct,
	year = {2009},
	note = {arXiv: 0904.2759},
	keywords = {Computer Science - Computational Complexity, Quantum Physics},
	pages = {544--551},
}

@article{hopcroft_n52_1973,
	title = {An \$n{\textasciicircum}\{5/2\} \$ {Algorithm} for {Maximum} {Matchings} in {Bipartite} {Graphs}},
	volume = {2},
	copyright = {[Copyright] © 1973 Society for Industrial and Applied Mathematics},
	issn = {00975397},
	url = {http://search.proquest.com/docview/919736551/abstract/79AD5CB7D4BA4C4EPQ/1},
	doi = {http://dx.doi.org.ezproxy.middlebury.edu/10.1137/0202019},
	abstract = {The present paper shows how to construct a maximum matching in a bipartite graph with \$n\$ vertices and \$m\$ edges in a number of computation steps proportional to \$(m + n){\textbackslash}sqrt n \$.},
	language = {English},
	number = {4},
	urldate = {2020-03-01},
	journal = {SIAM Journal on Computing; Philadelphia},
	author = {Hopcroft, John E. and Karp, Richard M.},
	month = dec,
	year = {1973},
	note = {Num Pages: 7
Place: Philadelphia, United States, Philadelphia
Publisher: Society for Industrial and Applied Mathematics},
	keywords = {Mathematics, Mathematics--Computer Applications},
	pages = {7},
}

@article{belovs_span_2012,
	title = {Span programs and quantum algorithms for st-connectivity and claw detection},
	volume = {7501},
	url = {http://arxiv.org/abs/1203.2603},
	doi = {10.1007/978-3-642-33090-2_18},
	abstract = {We introduce a span program that decides st-connectivity, and generalize the span program to develop quantum algorithms for several graph problems. First, we give an algorithm for st-connectivity that uses O(n d{\textasciicircum}\{1/2\}) quantum queries to the n x n adjacency matrix to decide if vertices s and t are connected, under the promise that they either are connected by a path of length at most d, or are disconnected. We also show that if T is a path, a star with two subdivided legs, or a subdivision of a claw, its presence as a subgraph in the input graph G can be detected with O(n) quantum queries to the adjacency matrix. Under the promise that G either contains T as a subgraph or does not contain T as a minor, we give O(n)-query quantum algorithms for detecting T either a triangle or a subdivision of a star. All these algorithms can be implemented time efficiently and, except for the triangle-detection algorithm, in logarithmic space. One of the main techniques is to modify the st-connectivity span program to drop along the way "breadcrumbs," which must be retrieved before the path from s is allowed to enter t.},
	urldate = {2020-02-28},
	journal = {arXiv:1203.2603 [quant-ph]},
	author = {Belovs, Aleksandrs and Reichardt, Ben W.},
	year = {2012},
	note = {arXiv: 1203.2603},
	keywords = {Quantum Physics},
	pages = {193--204},
}

@article{vazirani_simplification_2013,
	title = {A {Simplification} of the {MV} {Matching} {Algorithm} and its {Proof}},
	url = {http://arxiv.org/abs/1210.4594},
	abstract = {For all practical purposes, the Micali-Vazirani general graph maximum matching algorithm is still the most efficient known algorithm for the problem. The purpose of this paper is to provide a complete proof of correctness of the algorithm in the simplest possible terms; graph-theoretic machinery developed for this purpose also helps simplify the algorithm.},
	urldate = {2020-02-25},
	journal = {arXiv:1210.4594 [cs]},
	author = {Vazirani, Vijay V.},
	month = aug,
	year = {2013},
	note = {arXiv: 1210.4594},
	keywords = {Computer Science - Data Structures and Algorithms},
}
